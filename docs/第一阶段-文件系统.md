# 文件系统

在国赛第一阶段，我们实现了一个基于接口、支持多核、支持引用计数的文件系统。

## 锁机制
我们的VFS自底向上包含驱动层、buf层、cluster（扇区）层、FAT32文件系统层、文件描述符层这五大层次。

其中，驱动层、buf层、cluster层为了简化操作不加锁，而是由FAT32文件系统层维护一个锁，所有对磁盘文件系统的访问都需要加文件系统锁 `mtx_file`。这个锁保证了文件系统层的各个行为（文件查找、读写、删除等）是互斥的，保证了并发安全。而fd锁则是对kernFd（内核fd）加的锁，父子进程、多个线程因为共享一个kernFd而有可能发生并发访问文件描述符行为，而虽然下层会加锁，但是对fd本身的操作，如增减引用等需要互斥，所以设置了fd层锁 `fd_lock`.

`fd_lock` 和 `mtx_file` 都是睡眠锁。这是因为文件系统下层的操作有可能涉及硬盘读写，需要睡眠。

## 基本读、写、关闭接口封装
在fd（文件描述符）层，我们定义了“文件”的通用接口，包括：

**read**: `int read(int fd, u64 buf, size_t count)`

从 `fd` 读取 `count` 个字节存入到用户态的 `buf`，并移动fd偏移。

如果管道或socket为空且未关闭，则等待直到读取介质的状态变化；

如果管道或socket为空且已关闭，返回0，表示已到结尾；

否则，读取缓冲区内剩余的字符，如果不满count，则读取能读取的所有部分，然后返回。（read最多阻塞一次，允许读不够）

**write**: `int write(int fd, u64 buf, size_t count)`

向 `fd` 写入 `count` 个字节，并移动fd偏移。

如果管道或socket为空且未关闭，则等待直到状态改变；

若管道或socket为空且已经关闭，则返回 `-EPIPE`；

否则持续向管道或socket写入数据，直到数量足够，或者介质满且对端关闭为止；（write可以阻塞多次，如无意外必须写入count字节）

**close**: `int closeFd(int fd)`

释放进程的文件描述符，并将fd的引用计数减一。如归零，则清理fd并调用下层的关闭：

管道或socket：关闭一端，不再收或发数据；

文件：释放文件的引用；

## 基于睡眠的管道机制

### read

读写管道均需要对Pipe结构体这一读写双方共享的缓冲区加锁。睡眠时，需要传入这个锁来临时放锁，因为此时管道已满或者为空，需要对方继续操作完管道才能实现结束的条件，因为放锁让对方持有。

此外，sleep需要位于mtx_lock和mtx_unlock这一对加锁解锁函数之间，因为调用该函数会中途放锁。而wakeup虽然没有特殊必要，但还是建议放在加锁解锁之间。

```c
mtx_unlock_sleep(&fd->lock);

mtx_lock(&p->lock);
// 如果管道为空，则一直等待
warn("Thread %s: fd_pipe_read pipe %lx, content: %d B\n", cpu_this()->cpu_running->td_name, p, p->pipeWritePos - p->pipeReadPos);
while (p->pipeReadPos == p->pipeWritePos && !pipeIsClose(p) && !td->td_killed) {
	sleep(&p->pipeReadPos, &p->lock, "wait for pipe writer to write");
}

for (i = 0; i < n; i++) {
	if (p->pipeReadPos == p->pipeWritePos) {
		break;
	}
	ch = p->pipeBuf[p->pipeReadPos % PIPE_BUF_SIZE];
	copyOut((buf + i), &ch, 1);
	p->pipeReadPos++;
}

fd->offset += i;

// 唤醒可能在等待的写者
wakeup(&p->pipeWritePos);
mtx_unlock(&p->lock);

mtx_lock_sleep(&fd->lock);
```

### write



## console的设计

## 磁盘文件Dirent树

## 进程文件系统资源的管理

## buf层写回

## IO多路复用：pselect
