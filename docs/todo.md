## 未来想做的事情
<!-- 打钩： -->
<!-- [&#10004;] -->
[x] 做一个工具，能够自动从.c文件生成其对应的.h文件，并在Makefile中实现（gcc本身可实现）

[x] 引入分级日志，能够显示INFO, WARNING, FATAL三种类型的信息

[x] 实现内核的动态内存分配，可参考Linux的buddy systemh和slab等

[x] 更改Makefile的逻辑，将 `.c` 文件引入的 `.h` 加入到 `.c` 文件的依赖中，从而支持根据日期决定是否编译。教训：之前没有写 `.c` 到 `.h` 的依赖，结果 `.h` 中的定义改变之后 `.c` 编译成的 `.o` 文件并没有改变，导致出问题。

[x] 检测内核栈溢出是否会发出告警，之后设置一个尽量大的内核栈

[ ] 解决make不能多线程编译的问题

[ ] Syscall的Profiling

[ ] 发送SIGKILL信号后，将阻塞在IO上的syscall唤醒，继续完成接下来的事务，待syscall结束时才会最终kill。
syscall要保证自己只会进入一个阻塞IO，即被唤醒后就能立刻返回用户空间。现在一般的睡眠过程是睡眠等待某个条件成立，
比如管道读取是等待管道不为空或者管道关闭这二者之一成立。那么由SIGKILL完成的唤醒肯定不会满足这个条件，需要加一个额外的条件(td->td_killed)，帮助其顺利完成**拖尾**的syscall返回用户空间。TODO：之后需要检查每一个IO等待的睡眠是否存在这个问题。