## 同步互斥调试记录

由于同步互斥机制比较复杂，在扩充功能时容易出现问题，我们花了较长的时间调试这一部分的内容。

### 调度时栈问题（7 月上）

- 异常现象
    - 一个线程调度后无法调度下一个线程而跳飞

- 排查过程
    - 首先使用 gdb 断点调试，发现在 `sched_switch` 中使用了不正确的线程指针，导致恢复其内核线程现场时出错
    - 后尝试排查传入的线程指针，传入时参数无误，但是在 `sched_switch` 中出错，使用 gdb watchpoint 监视该线程指针，发现由另一个核心更改

- 问题原因
    - 在 `switch.S` 中没有考虑栈的问题，导致在 `sched_switch` 中继续使用了上一个线程的栈，此时若另一核心马上调度该线程，就会导致两个核心同时使用该线程的内核栈，导致栈污染从而出错

- 解决方案
    - 在 `sched_switch` 中使用内核的初始化栈，保证不会出现共用栈的情况

- 收获与反思
    - 最初设计时没有考虑 `sched_switch` 使用栈的情况，在后续拓展后 `sched_switch` 会调用其它函数从而使用栈。在拓展新功能时应慎重审视原有设计是否支持新功能的实现，避免出现类似问题（但是后续也多次发生了这种“新功能破坏旧功能”的问题）。

### 丢失唤醒问题

- 异常现象
    - 存在睡死现象，即某个线程一直在睡眠

- 排查过程
    - 打开调试输出，使用高并发进行测试，发现输出了唤醒日志但没有被唤醒
    - 因此是设计逻辑的问题

- 问题原因
    - 因为我们的设计里睡眠的关键是睡眠队列锁而不是线程锁，因此我们用线程锁换 `sleep` 传入的锁是不对的，存在以下情况会丢失唤醒。
        - 线程 A 调用 `wakeup` 拿了睡眠队列锁遍历睡眠队列
        - 线程 B 刚调用 `sleep` 换了线程锁，但还没加入睡眠队列
        - 此时 A 会检查睡眠队列发现没有 B，因此不会唤醒 B

- 解决方案
    - 睡眠应该拿传入的锁换睡眠队列锁，而不是线程锁

- 收获与反思
    - 由于设计不同，自己还是得多分析一下，不能将其他设计的思路直接套用到自己的设计上，这样会出现问题。

### 线程摧毁的丢失唤醒问题

- 异常现象
    - 进程回收时的不原子性引发了一系列问题如父进程丢失唤醒、子进程发信号出现异常、错误回收未释放完资源的进程控制块等

- 需要解决的问题
    - 最后一个线程结束被移出所属进程的线程队列（进程的线程队列清空）、进程变为僵尸态这二者必须保持原子性
        - 若先清空线程队列，会导致子进程给该进程发送信号时，该进程中没有线程，出现问题
        - 若先将进程变为僵尸态，会导致可能进程里的线程还没回收，父进程已经把这个进程控制块给回收了
    - 但是进程回收文件系统层的资源时，由于设计问题，必须需要睡眠，这就导致一定存在不原子性

- 解决方案
    - 调整了进程摧毁的设计
        - 先回收文件系统资源
        - 回收之后完成“清空线程、进程变为僵尸态”这一原子操作

- 收获与反思
    - 对于各种事件的发生顺序关系、哪些事件应当保持原子性、还是需要审慎考虑再进行操作。这次就是因为新增信号后，忘记了进程回收时的原子性问题，导致出现了一系列问题。
    - 底层的机制不能想当然就修改，要考虑到旧功能的兼容情况，系统的设计还是需要非常谨慎仔细的，不能随意修改。自己在拓展时还得多想想，多琢磨。这也让我体会到了操作系统拓展新功能真的很不容易，既要考虑到不能影响过往的功能，还得考虑到新功能的实现，真的是很难。